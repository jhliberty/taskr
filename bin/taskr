#!/usr/bin/env ruby

require 'time'
require 'optparse'

Filepath = File.expand_path("~/.data/tasks")

class Runner
  def self.execute

    tl = TaskList.new

    optparse = OptionParser.new do |opts|

      opts.on('-l', '--list', 'List all the tasks') do
        tl.list
        exit
      end
      opts.on('-L','--list-all' ,'List all the tasks' ) do
        tl.list(:all)
        exit
      end
      opts.on('-d','--delete' ,'Delete tasks(s)' ) do
        tl.delete(ARGV[1])
        exit
      end
      opts.on('-s','--search' ,'Search all the tasks' ) do
        tl.search(ARGV[1])
        exit
      end
      opts.on('-e','--edit' ,'Open the tasks file in vi' ) do
        system("vi #{Filepath}")
        exit
      end
      opts.on('-t','--tag' ,'Tag task(s)' ) do
        tl.tag(ARGV[1], ARGV[2])
        exit
      end
      opts.on('-u','--untag' ,'Untag task(s)' ) do
        tl.untag(ARGV[1], ARGV[2])
        exit
      end
      #opts.on('today','today','today') do
        #tag = Task::TagTransforms.find{|k,v| v == ':today'}.first
        #tl.tag(ARGV[1], tag)
        #exit
      #end
      opts.on('-p','--postpone','Postpone the task to tomorrow') do
        today_tag = Task::TagTransforms.find{|k,v| v == ':today'}.first
        tag = Task::TagTransforms.find{|k,v| v == ':tomorrow'}.first
        tl.tag(ARGV[1], tag)
        tl.untag(ARGV[1], today_tag)
        exit
      end
      #opts.on('-tray','tray','tray') do
        #tl.tag(ARGV[1], ':tray')
        #exit
      #end
      #opts.on('show','show','show') do
        #tl.show(ARGV[1])
        #exit
      #end
      opts.on('-x','--xmobar','Text to be shown in xmobar') do
        tl.xmobar
        exit
      end
      opts.on( '-h', '--help', 'Display this screen' ) do
        puts opts
        exit
      end
    end

    optparse.parse!

  end
end

#{{{Task
class Task
  #TODO: should always use date tags when marked as :today, :tomorrow
  #TODO: convert these to constants
  PriorityRegex =  /^([+-]+)|([+-]+)$/
  TagRegex = /(:[a-zA-Z0-9_:-]+)/
  TagTransforms = {
    (Time.now).strftime(":%Y%m%d") => ':today',
    (Time.now - 24 * 60 * 60).strftime(":%Y%m%d") => ':yesterday',
    (Time.now + 24 * 60 * 60 ).strftime(":%Y%m%d") => ':tomorrow'
  }

  attr_accessor :raw, :raw_time, :raw_text, :tags

  def initialize(opts)
    self.raw = opts[:raw]
    self.raw_time = opts[:raw_time]
    self.raw_text = opts[:raw_text]
    self.tags = opts[:tags]
  end

  def self.parse(line)
    tags = line.scan(TagRegex).flatten || []
    Task.new(raw_time: line[0..13].to_i, raw_text: line[15..-1], raw: line, tags: tags )
  end

  def to_s
    text_string = in_tray? ? self.text.colorize(background: :white, color: :black) : (self.transformed_tags.include?(':today') ? self.text.colorize(color: :cyan) : self.text)
    "#{id.colorize(:yellow)}. #{text_string} #{ tag_s } (#{self.time.colorize(:magenta)} #{self.priority_text.colorize(:light_yellow)})"
  end

  def tag_s
    pretty_tags = transformed_tags.map{|x| [':today', ':yesterday', ':tomorrow', ':weekend' ].include?(x) ? x.colorize(:light_yellow) : x.colorize(:yellow) }
    "[#{pretty_tags.join(' ')}]" unless pretty_tags.empty?
  end

  def serialize
    "#{self.raw_time} #{self.text} #{self.tags.join(' ')} #{self.priority_text}"
  end

  def priority
    -( in_tray? ? 100 : 0 + priority_text.count('*') + priority_text.count('+') - priority_text.count('-') + (self.visible? ? 2 : 0 ) + (self.tags.include?(:today) ? 3 : 0) )
  end

  def in_tray?
    self.tags.include?(':tray')
  end

  def visible?
    return true if Time.is_weekend? && tags.include?(':weekend')
    return false if tags.include?(':weekend') && !Time.is_weekend?

    return false if transformed_tags.include? ':tomorrow'
    return true
  end

  def priority_text
    raw_text.match(PriorityRegex).to_s
  end

  def time
    Time.strptime(raw_time.to_s,  "%Y%m%d%H%M%S").to_pretty
  end

  def id
    self.raw_time.to_s[8..-1].to_i.to_s_62
  end

  def transformed_tags
    tags.map{|x| TagTransforms[x] || x}
  end

  def text
    raw_text.gsub(TagRegex, '').gsub(PriorityRegex, '').strip
  end

end
#}}}

#{{{ TaskList
class TaskList

  def initialize
    @lines = File.readlines(Filepath).map{|x| x.chomp.strip}
    @tasks = @lines.map{|x| Task.parse(x)}.sort_by{|x| [x.priority, x.raw_time]}
  end

  def list(num = 5)
    print num == :all ? @tasks : @tasks.select{|x| x.visible?}
  end

  def search(q)
    print @tasks.select{|x| x.raw =~ /#{q}/i}
  end

  def print(tasks)
    puts "(#{tasks.count.to_s.colorize(:red)}) tasks"
    puts '---------------------'.colorize(:blue)
    tasks.each do |t|
      puts t
    end
  end

  def append(task)
    #TODO: decipher special tags like :today, :tomorrow
    File.open(Filepath, 'a') {|f| f.puts "#{Time.now.strftime "%Y%m%d%H%M%S"} #{task.strip}"}
  end

  def tag(id, tag)
    tasks = find(id)

    tag = ':' + tag unless tag =~ /^:.+/

    tasks.each {|task| task.tags << tag }
    save

    print tasks
  end

  def untag(id, tag)
    tasks = find(id)
    tasks.each {|task| task.tags.delete(tag) }
    save
    print tasks
  end

  def delete(id)
    tasks = find(id)
    tasks.each{|x| @tasks.delete(x)}
    save

    File.open(Filepath+".done", 'a') do |f|
      tasks.each{|task| f.puts "#{Time.now.strftime "%Y%m%d%H%M%S"} #{task.serialize}" }
    end
    puts tasks
  end

  def save
    task_data = @tasks.map{|x| x.serialize }.join("\n")
    File.open(Filepath, 'w') {|f| f.puts task_data}
  end

  def xmobar
    puts "(#{@tasks.find_all(&:visible?).count}/#{@tasks.count}) #{@tasks.find_all{|x| x.tags.include?(':tray') && x.visible? }.map{|x| x.text[0..20] + '.. '}.join(':')}"
  end

  def tasks
    @tasks
  end

  def find(ids)
    ids = ids.to_s.split(',')
    tasks = @tasks.find_all{|x| ids.include?(x.id)}
    return tasks if tasks && !tasks.empty?
    puts 'task(s) not found'.colorize(:red)
    exit 0
  end

  def show(id)
    print find(id)
  end

end
#}}}

#{{{ Fixnum extensions
class Fixnum
  SIXTYTWO = ('a'..'z').to_a
  def to_s_62
    i = self
    return '0' if i == 0
    s = ''
    while i > 0
      s << SIXTYTWO[i.modulo(26)]
      i /= 26
    end
    s.reverse
  end

end
#}}}

#{{{String extensions (colorize)
#
# Colorize String class extension.
#
class String



  #
  # Colors Hash
  #
  COLORS = {
    :black          => 0,
    :red            => 1,
    :green          => 2,
    :yellow         => 3,
    :blue           => 4,
    :magenta        => 5,
    :cyan           => 6,
    :white          => 7,
    :default        => 9,

    :light_black    => 10,
    :light_red      => 11,
    :light_green    => 12,
    :light_yellow   => 13,
    :light_blue     => 14,
    :light_magenta  => 15,
    :light_cyan     => 16,
    :light_white    => 17
  }

  #
  # Modes Hash
  #
  MODES = {
    :default        => 0, # Turn off all attributes
    #:bright        => 1, # Set bright mode
    :underline      => 4, # Set underline mode
    :blink          => 5, # Set blink mode
    :swap           => 7, # Exchange foreground and background colors
    :hide           => 8  # Hide text (foreground color would be the same as background)
  }

  protected

  #
  # Set color values in new string intance
  #
  def set_color_parameters( params )
    if (params.instance_of?(Hash))
      @color = params[:color]
      @background = params[:background]
      @mode = params[:mode]
      @uncolorized = params[:uncolorized]
      self
    else
      nil
    end
  end

  public

  #
  # Change color of string
  #
  # Examples:
  #
  #   puts "This is blue".colorize( :blue )
  #   puts "This is light blue".colorize( :light_blue )
  #   puts "This is also blue".colorize( :color => :blue )
  #   puts "This is light blue with red background".colorize( :color => :light_blue, :background => :red )
  #   puts "This is light blue with red background".colorize( :light_blue ).colorize( :background => :red )
  #   puts "This is blue text on red".blue.on_red
  #   puts "This is red on blue".colorize( :red ).on_blue
  #   puts "This is red on blue and underline".colorize( :red ).on_blue.underline
  #   puts "This is blue text on red".blue.on_red.blink
  #   puts "This is uncolorized".blue.on_red.uncolorize
  #
  def colorize( params )
    return self unless STDOUT.isatty
    return self if self.frozen?

    begin
      require 'Win32/Console/ANSI' if RUBY_PLATFORM =~ /win32/
    rescue LoadError
      raise 'You must gem install win32console to use colorize on Windows'
    end

    color_parameters = {}

    if (params.instance_of?(Hash))
      color_parameters[:color] = COLORS[params[:color]]
      color_parameters[:background] = COLORS[params[:background]]
      color_parameters[:mode] = MODES[params[:mode]]
    elsif (params.instance_of?(Symbol))
      color_parameters[:color] = COLORS[params]
    end

    color_parameters[:color] ||= @color ||= COLORS[:default]
    color_parameters[:background] ||= @background ||= COLORS[:default]
    color_parameters[:mode] ||= @mode ||= MODES[:default]

    color_parameters[:uncolorized] ||= @uncolorized ||= self.dup

    # calculate bright mode
    color_parameters[:color] += 50 if color_parameters[:color] > 10

    color_parameters[:background] += 50 if color_parameters[:background] > 10

    "\033[#{color_parameters[:mode]};#{color_parameters[:color]+30};#{color_parameters[:background]+40}m#{color_parameters[:uncolorized]}\033[0m".set_color_parameters( color_parameters )
  end

  #
  # Return uncolorized string
  #
  def uncolorize
    @uncolorized || self
  end

  #
  # Return true if sting is colorized
  #
  def colorized?
    !defined?(@uncolorized).nil?
  end

  #
  # Make some color and on_color methods
  #
  COLORS.each_key do | key |
    next if key == :default

  define_method key do
    self.colorize( :color => key )
  end

  define_method "on_#{key}" do
    self.colorize( :background => key )
  end
  end

  #
  # Methods for modes
  #
  MODES.each_key do | key |
    next if key == :default

  define_method key do
    self.colorize( :mode => key )
  end
  end

  class << self

    #
    # Return array of available modes used by colorize method
    #
    def modes
      keys = []
      MODES.each_key do | key |
        keys << key
      end
      keys
    end

    #
    # Return array of available colors used by colorize method
    #
    def colors
      keys = []
      COLORS.each_key do | key |
        keys << key
      end
      keys
    end

    #
    # Display color matrix with color names.
    #
    def color_matrix( txt = "[X]" )
      size = String.colors.length
      String.colors.each do | color |
        String.colors.each do | back |
        print txt.colorize( :color => color, :background => back )
      end
      puts " < #{color}"
      end
      String.colors.reverse.each_with_index do | back, index |
        puts "#{"|".rjust(txt.length)*(size-index)} < #{back}"
      end
      ""
    end
  end
end
#}}}

#{{{Time extensions
class Time

  def self.is_weekend?
    self.now.is_weekend?
  end

  def is_weekend?
    self.wday > 5
  end

  def to_pretty
    a = (Time.now-self).to_i

    case a
    when 0 then return 'just now'
    when 1 then return 'a second ago'
    when 2..59 then return a.to_s+' seconds ago'
    when 60..119 then return 'a minute ago' #120 = 2 minutes
    when 120..3540 then return (a/60).to_i.to_s+' minutes ago'
    when 3541..7100 then return 'an hour ago' # 3600 = 1 hour
    when 7101..82800 then return ((a+99)/3600).to_i.to_s+' hours ago'
    when 82801..172000 then return 'a day ago' # 86400 = 1 day
    when 172001..518400 then return ((a+800)/(60*60*24)).to_i.to_s+' days ago'
    when 518400..1036800 then return 'a week ago'
    end
    return ((a+180000)/(60*60*24*7)).to_i.to_s+' weeks ago'
  end
end

#}}}
#

Runner.execute
